---
title: 'Project tests'
description: 'Write SQL queries to validate specific data conditions in your workflows'
---

Project tests are custom SQL queries that validate your data by checking whether a specific table or combination of database objects meets a certain condition. You build each project test as a test for a particular workflow or transformation.

Use project tests when you need to validate data that combines multiple models or tables, or when you want to test a specific transformation pipeline. For example, you might create a project test to verify referential integrity across related tables or ensure that a complex data transformation produces expected results.

<Note>
  Project tests are based on [dbt singular data
  tests](https://docs.getdbt.com/docs/build/data-tests#singular-data-tests).
</Note>

<Tip>
  Use **project tests** when you need to test a specific workflow or combination of models that
  won't be reused elsewhere. Use [test
  definitions](/data-analytics/development/tests/use-model-tests) when you want to apply the same
  standardized test (like checking for uniqueness or null values) across multiple tables or models
  in your project.
</Tip>

## Test parameters

When you create a project test, a Data Test gem appears on an otherwise empty canvas. The Data Test gem has the following optional parameters:

| Parameter               | Description                                                                                                                                                                                       | Default          |
| ----------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ---------------- |
| **Failure Calculation** | Sets the failure condition. The error and warning conditions are measured against this calculation.                                                                                               | `count(*)`       |
| **Limit**               | Sets the maximum number of failures returned by a test query. You can set the limit to save resources by having the test stop its query as soon as it encounters a certain number of failed rows. | Empty (no limit) |
| **Severity**            | Determines whether the failure of the test returns an error or warning.                                                                                                                           | `error`          |
| **Error If**            | Sets the condition to determine an error. If the condition is met, and the severity is set to error, the tests returns an error.                                                                  | `!=0`            |
| **Warning If**          | Sets the condition to determine a warning. If the condition is met, and the severity is set to error or warning, the tests returns a warning.                                                     | `!=0`            |

If you leave all parameters empty, Prophecy uses the default values. The test passes when the query returns no rows. If the query returns any rows, the test returns an error.

## Build and run a test

This example creates a test named `assert_total_payment_amount_is_positive` that validates payment data. For each order, there might be multiple transactions: negative transactions represent refunds. The total payment amount for an order is the sum of all transaction amounts, and should never be negative (greater than or equal to zero). Let's build a project test to validate this for a table.

### 1. Create a project test entity

To develop a project test, start by opening a project:

1. In the left sidebar, click **+ Add Entity**.
1. Hover the **Tests** option and select **Project tests**.
1. Enter a name for your test, such as `assert_total_payment_amount_is_positive`.
1. Keep the default path `tests` where Prophecy will store the test.
1. Click **Create** to create your new test.

### 2. Develop a test model

Let's prepare the data for the `assert_total_payment_amount_is_positive` test. Our test checks checks if the table has any rows. Because of this, we need to add a filter to the original table to return the rows that will make the test fail. In this case, we want to return the rows where the total amount is negative.

1. Drag a table to evaluate onto the canvas.

   In this example, we'll use a `payments` table:

   | order_id | amount  |
   | -------- | ------- |
   | ORD-001  | 150.00  |
   | ORD-001  | -25.00  |
   | ORD-002  | 200.00  |
   | ORD-003  | 100.00  |
   | ORD-003  | -150.00 |

1. Add an Aggregate gem to the pipeline after the `payments` table.
1. Configure the Aggregate gem to sum the amounts for each order.
1. Add a Filter gem after the Aggregate gem.
1. Configure the Filter gem to return only the orders where the total amount is negative.
1. Connect the Filter gem to the **Data Test** gem.

<Check>Because `ORD-003` has a negative total amount, the test will return an error.</Check>

### 3. Configure the Data Test gem

The Data Test gem should validate that the total amount for each order is always greater than or equal to zero. To do so, the test identifies orders where the sum of all payment amounts is negative.

1. Open the **Data Test** gem.
1. Keep the default parameters. Without modifying the parameters, the test returns an error if the input to the Data Test gem has any rows.
1. The **Final Query** code editor displays the SQL query that results from your visual test pipeline. You do not need to edit this query. This is the query that the test will run against.
1. Click **Save**.

### 4. Run the project test

To run the test:

1. Click the **Play** button on the canvas or on the Data Test gem.
1. The test runs against the input to the Data Test gem. For the `assert_total_payment_amount_is_positive` example, the test executes the SQL query against the output of the Filter gem.
1. Click **See Run Details** in the top right of the canvas to view the test summary.

   ![See Run Details](/data-analytics/development/tests/img/project-test-run-details.png)

1. Prophecy displays the final test status (succeeded, warning, or failed).
1. To troubleshoot failed tests, click to expand the logs and review the dbt logs. The example test fails because `ORD-003` has a negative total amount.

   ![Test logs](/data-analytics/development/tests/img/project-test-logs.png)

<Info>
  You can execute a partial pipeline run by clicking play on an intermediate gem. However, since the
  execution stops before reaching the Data Test gem, the test will not run.
</Info>

### 5. Schedule test runs

When you schedule a pipeline, you can also configure project tests to run during that schedule.

1. Open a pipeline to associate the project tests schedule with.
1. In the project header, click **... > Schedule**.
1. Edit the existing schedule or configure a new schedule.
1. Under **Project level tests**, select the tests you want to schedule.
1. Click **Confirm** to save the changes.

<Info>

You must enable the schedule and publish the project to activate the automation.

Learn more in [Schedule activation](/data-analytics/production/scheduling/scheduling#schedule-activation).

</Info>

<Accordion title="Schedule test runs (Models ONLY)">

Pipeline schedules differ from model schedules. Use the following steps if you are using **scheduling models only**.

1. In the left sidebar of the project, click **+ Add Entity**.
1. Click **Job**. This opens the **Create Job** dialog.
1. Enter a name for your job and click **Create New**.
1. Drag a **Model** gem to your visual canvas.
1. Click the model to open the model properties.
1. Select the database object you want to run the test on.
1. Select the **Run tests** checkbox in the left sidebar of the model gem.
1. Ensure that your **project, model**, and **fabric** are correct.
1. Click **Save**.

</Accordion>

## Test failure vs. execution error

When a project test fails, it can be due to one of two reasons:

### Test failure (data quality issue)

The SQL query returns one or more rows, indicating that your data violates the test condition. This means the test is working correctly, but your data doesn't meet the expected criteria.

For example, in the `assert_total_payment_amount_is_positive` test, if the query returns rows, it means there are orders with negative total payment amounts.

### Execution error (configuration or setup issue)

The test cannot run properly due to a technical problem. Common causes include:

- The input table no longer exists or the input data sources are inaccessible.
- The **Failure Calculation** function is invalid or contains syntax errors.
- The **Error If** or **Warning If** conditions are invalid or contain syntax errors.
- The SQL query itself has syntax errors.
