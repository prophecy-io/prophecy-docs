---
title: 'Project tests'
description: 'Custom SQL query tests'
---

Project tests are custom SQL queries that validate your data by checking whether a specific table or combination of database objects meets a certain condition. You build each project test as a test for a particular workflow or transformation.

Use project tests when you need to validate data that combines multiple models or tables, or when you want to test a specific transformation pipeline. For example, you might create a project test to verify referential integrity across related tables or ensure that a complex data transformation produces expected results.

By default, a project test passes when the query returns no rows. If the query returns any rows, the test fails, indicating that the data doesn't meet the specified condition.

<Note>
  Project tests are based on [dbt singular data
  tests](https://docs.getdbt.com/docs/build/data-tests#singular-data-tests).
</Note>

<Tip>
  Use **project tests** when you need to test a specific workflow or combination of models that
  won't be reused elsewhere. Use [test
  definitions](/data-analytics/development/tests/use-model-tests) when you want to apply the same
  standardized test (like checking for uniqueness or null values) across multiple tables or models
  in your project.
</Tip>

## Test parameters

When you create a project test, a Data Test gem appears on an otherwise empty canvas. The Data Test gem has the following parameters:

| Parameter               | Description                                                                                                                                                                                                                                                                                                                                                                                                                |
| ----------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Failure Calculation** | Sets the failure condition used to run against the test result. You can use the `count()` function on a column or multiple columns.                                                                                                                                                                                                                                                                                        |
| **Limit**               | Sets the maximum number of failures returned by a test query. You can set the limit to save resources and time by having the test stop its query as soon as it encounters a certain number of failed rows.                                                                                                                                                                                                                 |
| **Severity**            | Determines whether the failure of the test returns an error or warning. The severity operates from the highest priority selection, error, to the lowest, warning. So if you select error, then the test first checks for errors. If it doesn't find any, then it then checks for warnings. If you select warning, then the test only checks for warnings. If you don't select a severity, then error is chosen by default. |
| **Error If**            | Sets the number of failed rows to determine a failed test. Depending on the selected severity, your test only returns a failed test for error checks. Warning won't return a failed test.                                                                                                                                                                                                                                  |
| **Warning If**          | Sets the number of failed rows to determine a warning. Only evaluated when severity is set to error (checks warnings after errors) or when severity is set to warning.                                                                                                                                                                                                                                                     |

## Build and run a test

### 1. Create a project test entity

To develop a project test, start by opening a project:

1. In the left sidebar, click **+ Add Entity**.
1. Hover the **Tests** option and select **Project tests**.
1. Enter a name for your test, such as `customer_churn`. Project tests are saved to a `/tests` directory in the project Git repository by default.
1. Click **Create** to create your new test.

### 2. Develop a test model

Create your test model by

1. Dragging and dropping tables and other gems onto your visual canvas.
1. Connect them to the **Data Test** gem.

<Info>You can also write your test in the Code view.</Info>

### 3. Configure the Data Test gem

You can configure your own passing condition for a project test to focus on specific cases. The following example demonstrates how to configure a test for a customer churn use case where you need to identify customers with more than five comments, indicating they may need additional support.

In this example, the test checks a table where each row represents a customer comment. When the number of comments for a customer exceeds five, the test flags this condition so you can take action, such as assigning more resources to assist that customer.

1. Open the **Data Test** gem.

1. Enter values for the following fields:

1. (Optional) Select the **Use Custom Query** checkbox and enter a custom SQL query for the test.

1. Click **Save**.

### 4. Run a test

To run the test:

1. Click the **Play** button on the canvas or on the Data Test gem.

1. The test runs against the input to the Data Test gem.

1. Prophecy produces interim data after the Data Test gem.

1. Prophecy displays the final test status (succeeded, warning, or failed) in a summary.

1. Click **See Run Details** in the top right of the canvas to view the test summary. Depending on the outcome of the test, the icon displays a different color.

   ![See Run Details](/data-analytics/development/tests/img/project-test-run-details.png)

   You can click to expand the test logs in the Summary to view the dbt logs.

   ![View test summary](/data-analytics/development/tests/img/project-test-summary.png)

In addition to the previous relational integrity test, you can create tests to check that the total payment amount from customers is positive or simply check that all of your tables are still accessible. You can test any series of transformation gems, because a project test simply asserts that the resulting table meets a certain criteria.

<Info>
  You can execute a partial pipeline run by clicking play on an intermediate gem. However, since the
  execution stops before reaching the Data Test gem, the test will not run.
</Info>

## 5. Fix a failed test

If your project test fails, click the test output to see your failed rows.

![View test summary](/data-analytics/development/tests/img/project-test-failed-test.png)

Some examples of test failure causes include:

- The SQL query returns a row. This means the actual test failed.

Other possible causes include:

- The input table no longer exists since one or more input data sources were deleted or inaccessible
- The Failure Calculation function is invalid
- The Error If and Warn If conditions are invalid

By default, project tests are configured to fail if the table has one or more rows. You can also modify the passing condition of your test through advanced options.

<Accordion title="Schedule test runs (Models ONLY)">

When you schedule a project, you can also schedule tests in the project to run. Scheduling tests ensures that your data is correct on a regular basis.

1. In the left sidebar of the project, click **+ Add Entity**.
1. Click **Job**. This opens the **Create Job** dialog.
1. Enter a name for your job and click **Create New**.
1. Drag a **Model** gem to your visual canvas.
1. Click the model to open the model properties.
1. Select the database object you want to run the test on.
1. Select the **Run tests** checkbox in the left sidebar of the model gem.
1. Ensure that your **project, model**, and **fabric** are correct.
1. Click **Save**.

</Accordion>

## Example: Referential integrity check

The following test named `ref_int_orders_customers` checks for referential integrity. In particular, it checks if every `customer_id` entry in the **orders** table is present in the **customers** table.

This test starts with several models from the `HelloWorld_SQL` project, combines their data with a series of transformation steps, and feeds the resulting table into the Data Test gem.

If there are `customer_id` entries in the **orders** table that are not present in the **customers** table, then the `ref_int_orders_customers` test fails.
