---
title: 'Project tests'
description: 'Write SQL queries to validate specific data conditions in your workflows'
---

Project tests are custom SQL queries that validate your data by checking whether a specific table or combination of database objects meets a certain condition. You build each project test as a test for a particular workflow or transformation.

Use project tests when you need to validate data that combines multiple models or tables, or when you want to test a specific transformation pipeline. For example, you might create a project test to verify referential integrity across related tables or ensure that a complex data transformation produces expected results.

By default, a project test passes when the query returns no rows. If the query returns any rows, the test fails, indicating that the data doesn't meet the specified condition.

<Note>
  Project tests are based on [dbt singular data
  tests](https://docs.getdbt.com/docs/build/data-tests#singular-data-tests).
</Note>

<Tip>
  Use **project tests** when you need to test a specific workflow or combination of models that
  won't be reused elsewhere. Use [test
  definitions](/data-analytics/development/tests/use-model-tests) when you want to apply the same
  standardized test (like checking for uniqueness or null values) across multiple tables or models
  in your project.
</Tip>

## Test parameters

When you create a project test, a Data Test gem appears on an otherwise empty canvas. The Data Test gem has the following optional parameters:

| Parameter               | Description                                                                                                                                                                                                                                                                                                                                                                                                                |
| ----------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Failure Calculation** | Sets the failure condition. The limit, error, and warning condition is measured against this calculation.                                                                                                                                                                                                                                                                                                                  |
| **Limit**               | Sets the maximum number of failures returned by a test query. You can set the limit to save resources and time by having the test stop its query as soon as it encounters a certain number of failed rows.                                                                                                                                                                                                                 |
| **Severity**            | Determines whether the failure of the test returns an error or warning. The severity operates from the highest priority selection, error, to the lowest, warning. So if you select error, then the test first checks for errors. If it doesn't find any, then it then checks for warnings. If you select warning, then the test only checks for warnings. If you don't select a severity, then error is chosen by default. |
| **Error If**            | Sets the number of failed rows to determine a failed test. Depending on the selected severity, your test only returns a failed test for error checks. Warning won't return a failed test.                                                                                                                                                                                                                                  |
| **Warning If**          | Sets the number of failed rows to determine a warning. Only evaluated when severity is set to error (checks warnings after errors) or when severity is set to warning.                                                                                                                                                                                                                                                     |

## Build and run a test

This example creates a test named `assert_total_payment_amount_is_positive` that validates payment data.

### 1. Create a project test entity

To develop a project test, start by opening a project:

1. In the left sidebar, click **+ Add Entity**.
1. Hover the **Tests** option and select **Project tests**.
1. Enter a name for your test, such as `assert_total_payment_amount_is_positive`.
1. Keep the default path `tests` where Prophecy will store the test.
1. Click **Create** to create your new test.

### 2. Develop a test model

Create your test model by connecting your data sources to the Data Test gem. For the `assert_total_payment_amount_is_positive` example:

1. Drag a table to evaluate onto the canvas.

   In this example, we'll use a `fct_payments` table:

   | order_id | amount  |
   | -------- | ------- |
   | ORD-001  | 150.00  |
   | ORD-001  | -25.00  |
   | ORD-002  | 200.00  |
   | ORD-003  | 100.00  |
   | ORD-003  | -150.00 |

1. Connect the `fct_payments` table to the **Data Test** gem.

### 3. Configure the Data Test gem

The Data Test gem should validate that the total amount for each order is always greater than or equal to zero. To do so, the test identifies orders where the sum of all payment amounts is negative.

1. Open the **Data Test** gem.
1. Configure the test parameters.
   - **Failure Calculation**: `count(*)`
   - **Limit**: `100` (stops after finding 100 orders with negative totals)
   - **Severity**: `error`
   - **Error If**: `> 0` (fails if any orders have negative total amounts)

1. Select the **Use Custom Query** checkbox to enter a custom SQL query.
1. Enter the following SQL query in the custom query field:

   ```sql
   SELECT
      order_id,
      sum(amount) as total_amount
   FROM fct_payments
   GROUP BY order_id
   HAVING total_amount < 0
   ```

1. Click **Save**.

<Info>You can also write your test in the Code view.</Info>

### 4. Run the project test

To run the test:

1. Click the **Play** button on the canvas or on the Data Test gem.
1. The test runs against the input to the Data Test gem. For the `assert_total_payment_amount_is_positive` example, the test executes the SQL query against your `fct_payments` table.
1. Click **See Run Details** in the top right of the canvas to view the test summary. Depending on the outcome of the test, the icon displays a different color.

   ![See Run Details](/data-analytics/development/tests/img/project-test-run-details.png)

1. Prophecy displays the final test status (succeeded, warning, or failed).
1. To troubleshoot failed tests, click to expand the logs and review the dbt logs.

<Info>
  You can execute a partial pipeline run by clicking play on an intermediate gem. However, since the
  execution stops before reaching the Data Test gem, the test will not run.
</Info>

<Accordion title="Schedule test runs (Models ONLY)">

When you schedule a project, you can also schedule tests in the project to run. Scheduling tests ensures that your data is correct on a regular basis.

1. In the left sidebar of the project, click **+ Add Entity**.
1. Click **Job**. This opens the **Create Job** dialog.
1. Enter a name for your job and click **Create New**.
1. Drag a **Model** gem to your visual canvas.
1. Click the model to open the model properties.
1. Select the database object you want to run the test on.
1. Select the **Run tests** checkbox in the left sidebar of the model gem.
1. Ensure that your **project, model**, and **fabric** are correct.
1. Click **Save**.

</Accordion>

## Test failure vs. execution error

When a project test fails, it can be due to one of two reasons:

### Test failure (data quality issue)

The SQL query returns one or more rows, indicating that your data violates the test condition. This means the test is working correctly, but your data doesn't meet the expected criteria.

For example, in the `assert_total_payment_amount_is_positive` test, if the query returns rows, it means there are orders with negative total payment amounts.

### Execution error (configuration or setup issue)

The test cannot run properly due to a technical problem. Common causes include:

- The input table no longer exists or the input data sources are inaccessible.
- The **Failure Calculation** function is invalid or contains syntax errors.
- The **Error If** or **Warning If** conditions are invalid or contain syntax errors.
- The SQL query itself has syntax errors.
